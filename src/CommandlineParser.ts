/**
 * This is the parser for the the commandline interface for ossf-cve-benchmark.
 *
 * This is the file that parses the `bin/cli` commands mentioned throughout the documentation of this projects.
 */

import * as argparse from "argparse";
import { getSupportedSyntaxExplanations } from "./selectors";

/**
 * A supported command.
 */
export enum Command {
  LIST,
  FILTER,
  TOOLS,
  RUN,
  EXPORT,
  REPORT,
  DOWNLOAD_COMMITS,
  UPLOAD_COMMITS,
  VALIDATE
}
/**
 * A supported argument kind.
 */
enum Arg {
  CONFIG_FILE,
  BCVES,
  SOURCES,
  RESULTS,
  RUN_TOOL,
  FILTER_TOOL,
  NO_SOURCES,
  ANONYMIZE,
  ALLOW_INCOMPLETE,
  SELECTORS,
  IMPORT,
  NON_FATAL_VALIDATION_ERRORS,
  LIST_FULL,
  REPORTS,
  REPORT_KIND,
  INVERT_MATCH,
  ANONYMOUS,
  SCHEMA,
  AUTH_TOKEN,
  VALIDATE_FILES,
  NO_EXPORT_FILE,
  EXPORT
}

const strings = {
    /**
     * The user-facing names
     */
    names: {
      /**
       * @return the string that should be typed on the commandline to make use of `command`
       */
      getCommandName: function (command: Command) {
        switch (command) {
          case Command.REPORT:
            return "report";
          case Command.LIST:
            return "list";
          case Command.FILTER:
            return "filter";
          case Command.TOOLS:
            return "tools";
          case Command.RUN:
            return "run";
          case Command.EXPORT:
            return "export";
          case Command.DOWNLOAD_COMMITS:
            return "download-commits";
          case Command.VALIDATE:
            return "validate";
          case Command.UPLOAD_COMMITS:
            return "upload-commits";
        }
      },
      /**
       * @return the string that should be typed on the commandline to make use of `arg`
       */
      getArgumentName: function (arg: Arg) {
        switch (arg) {
          case Arg.CONFIG_FILE:
            return "--config-file";
          case Arg.NON_FATAL_VALIDATION_ERRORS:
            return "--non-fatal-validation-errors";
          case Arg.BCVES:
            return "--bcves";
          case Arg.SOURCES:
            return "--sources";
          case Arg.RESULTS:
            return "--results";
          case Arg.RUN_TOOL:
            return "--tool";
          case Arg.FILTER_TOOL:
            return "--tool";
          case Arg.NO_SOURCES:
            return "--no_sources";
          case Arg.ANONYMIZE:
            return "--anonymize";
          case Arg.ALLOW_INCOMPLETE:
            return "--allow-incomplete";
          case Arg.IMPORT:
            return "--import";
          case Arg.SELECTORS:
            return "selectors";
          case Arg.LIST_FULL:
            return "--full";
          case Arg.REPORTS:
            return "--reports";
          case Arg.REPORT_KIND:
            return "--kind";
          case Arg.INVERT_MATCH:
            return "--invert-match";
          case Arg.ANONYMOUS:
            return "--anonymous";
          case Arg.SCHEMA:
            return "--schema";
          case Arg.AUTH_TOKEN:
            return "--auth-token";
          case Arg.VALIDATE_FILES:
            return "files";
          case Arg.NO_EXPORT_FILE:
            return "--no-export-file";
          case Arg.EXPORT:
            return "--export";
        }
      }
    },
    /**
     * The user-facing help strings.
     */
    help: {
      main: () => {
        return [
          "CLI for ossf-cve-benchmark",
          "",
          "The following commands are available:"
        ]
          .concat(
            Object.keys(Command)
              .filter(k => isNaN(Number(k)))
              .map(
                (k: keyof typeof Command) =>
                  `- ${strings.names.getCommandName(
                    Command[k]
                  )}: ${strings.help.getCommandHelp(Command[k])}`
              )
              .sort()
          )
          .join("\n");
      },
      /**
       * @return the help string for and argument of kind `arg`
       */
      getArgumentHelp: (arg: Arg) => {
        switch (arg) {
          case Arg.CONFIG_FILE:
            return "The configuration file to use (default: config.json of the working directory)";
          case Arg.NON_FATAL_VALIDATION_ERRORS:
            return "Makes JSON Schema validation errors of various JSON files non-fatal";
          case Arg.BCVES:
            return "The directory that contains the benchmark CVEs (default: `/CVEs` of the project directory.)";
          case Arg.SOURCES:
            return "The directory that contains source code of the benchmark CVE commits (default: `/work/sources` of the project directory.)";
          case Arg.RESULTS:
            return "The directory that contains analysis tool driver results (default: `/work/results` of the project directory.)";
          case Arg.NO_SOURCES:
            return "Assumes no commits of any benchmark CVE are available locally when set";
          case Arg.ANONYMIZE:
            return "Anonymizes the IDs of tools and rules when set";
          case Arg.ALLOW_INCOMPLETE:
            return "Enables the use of incomplete benchmark CVEs when set";
          case Arg.IMPORT:
            return "The file to import data from instead of files in local directories";
          case Arg.SELECTORS:
            return [
              "The CVE selectors that select the benchmark CVEs to use (disjunctive)"
            ]
              .concat(["Selectors:"])
              .concat(getSupportedSyntaxExplanations().map(l => `- ${l}`))
              .concat([
                "",
                "If a single '-' is used as a selector, the above selectors are read from stdin"
              ])
              .join("\n");
          case Arg.RUN_TOOL:
            return "The IDs of the analysis tool driver to run. The ID is used to look up the driver in the configuration file. (repeatable)";
          case Arg.FILTER_TOOL:
            return "The ID of the analysis tool driver to use results for. (repeatable)";
          case Arg.LIST_FULL:
            return "Display the full information for the CVE, instead of just the CVE identifier";
          case Arg.REPORTS:
            return "The directory that contains reports from the `report` command (default: `/work/report` of the project directory.)";
          case Arg.REPORT_KIND:
            return "The kind of report to generate";
          case Arg.INVERT_MATCH:
            return "Inverts the matching (similar to `grep --invert-match``)";
          case Arg.ANONYMOUS:
            return "Downloads commits anonymously (note that rate-limits may be more restrictive)";
          case Arg.SCHEMA:
            return "The name of the JSON schema to validate with";
          case Arg.AUTH_TOKEN:
            return "The (secret) authorization token to use for access to the remote repository";
          case Arg.VALIDATE_FILES:
            return "The files to validate";
          case Arg.NO_EXPORT_FILE:
            return "Output the exported data to stdout instead of a file";
          case Arg.EXPORT:
            return "The file to write the export to (default: `/work/export/export.json` of the project directory.)";
        }
      },
      /**
       * @return the help string for `command`
       */
      getCommandHelp: (command: Command) => {
        switch (command) {
          case Command.LIST:
            return "Lists the selected CVEs";
          case Command.FILTER:
            return "Filters CVEs by inspecting the CVE data content (similar to grep)";
          case Command.TOOLS:
            return "Displays the analysis tools that are available for the `run` command";
          case Command.RUN:
            return "Runs analysis tools on the source code of the selected CVEs";
          case Command.EXPORT:
            return "Exports the selected data to a single, distributable file";
          case Command.REPORT:
            return "Generates reports of different kinds";
          case Command.DOWNLOAD_COMMITS:
            return "Downloads the relevant commits for the selected CVEs";
          case Command.VALIDATE:
            return "Validates the provided files with respect to a JSON schema";
          case Command.UPLOAD_COMMITS:
            return "Uploads the relevant commits for the selected CVEs";
        }
      }
    }
  },
  /**
   * Utilities for using the `Arg` type.
   */
  argUtil = {
    /**
     * Adds `arg` to `parser`, using `options`.
     */
    addArg: function (
      arg: Arg,
      parser: argparse.ArgumentParser,
      options: argparse.ArgumentOptions = {}
    ) {
      options = { ...options };
      if (
        [
          Arg.ANONYMIZE,
          Arg.ALLOW_INCOMPLETE,
          Arg.NON_FATAL_VALIDATION_ERRORS,
          Arg.NO_SOURCES,
          Arg.INVERT_MATCH,
          Arg.ANONYMOUS,
          Arg.NO_EXPORT_FILE,
          Arg.LIST_FULL
        ].includes(arg)
      ) {
        options.action = "store_true";
      }
      if ([Arg.SELECTORS, Arg.VALIDATE_FILES].includes(arg)) {
        options.nargs = "+";
        delete options.required;
      }
      if ([Arg.SCHEMA].includes(arg)) {
        options.choices = ["BCVE", "Log", "Export", "Config"];
      }
      if ([Arg.REPORT_KIND].includes(arg)) {
        options.choices = ["txt", "server"];
      }
      if (arg === Arg.FILTER_TOOL || arg === Arg.RUN_TOOL) {
        options.action = "append";
      }
      options.help = strings.help.getArgumentHelp(arg);
      parser.add_argument(strings.names.getArgumentName(arg), options);
    },

    /**
     * Adds `args` to `parser` as optional arguments.
     */
    addOptionalArgs: function (args: Arg[], parser: argparse.ArgumentParser) {
      args.forEach(arg => {
        argUtil.addArg(arg, parser, { required: false });
      });
    },
    /**
     * Adds `args` to `parser` as mandatory arguments.
     */
    addArgs: function (args: Arg[], parser: argparse.ArgumentParser) {
      args.forEach(arg => {
        argUtil.addArg(arg, parser, { required: true });
      });
    }
  };

/**
 * @return a function that sets up the subparser for `command`
 */
function getSubparserSetup(
  command: Command
): (parser: argparse.ArgumentParser) => void {
  switch (command) {
    case Command.REPORT:
      return parser => {
        argUtil.addOptionalArgs(
          [
            Arg.CONFIG_FILE,
            Arg.NON_FATAL_VALIDATION_ERRORS,
            Arg.BCVES,
            Arg.SOURCES,
            Arg.REPORTS,
            Arg.RESULTS,
            Arg.ANONYMIZE,
            Arg.ALLOW_INCOMPLETE,
            Arg.NO_SOURCES,
            Arg.IMPORT,
            Arg.FILTER_TOOL
          ],
          parser
        );
        argUtil.addArgs([Arg.REPORT_KIND, Arg.SELECTORS], parser);
      };
    case Command.LIST:
      return parser => {
        argUtil.addOptionalArgs(
          [
            Arg.CONFIG_FILE,
            Arg.NON_FATAL_VALIDATION_ERRORS,
            Arg.BCVES,
            Arg.NO_SOURCES,
            Arg.SOURCES,
            Arg.LIST_FULL
          ],
          parser
        );
        argUtil.addArgs([Arg.SELECTORS], parser);
      };
    case Command.FILTER:
      return parser => {
        argUtil.addOptionalArgs(
          [
            Arg.CONFIG_FILE,
            Arg.NON_FATAL_VALIDATION_ERRORS,
            Arg.BCVES,
            Arg.INVERT_MATCH
          ],
          parser
        );
        argUtil.addArgs([Arg.SELECTORS], parser);
      };
    case Command.TOOLS:
      return parser => {
        argUtil.addOptionalArgs(
          [Arg.CONFIG_FILE, Arg.NON_FATAL_VALIDATION_ERRORS],
          parser
        );
      };
    case Command.RUN:
      return parser => {
        argUtil.addOptionalArgs(
          [
            Arg.CONFIG_FILE,
            Arg.NON_FATAL_VALIDATION_ERRORS,
            Arg.BCVES,
            Arg.SOURCES,
            Arg.RESULTS
          ],
          parser
        );
        argUtil.addArgs([Arg.RUN_TOOL, Arg.SELECTORS], parser);
      };
    case Command.EXPORT:
      return parser => {
        argUtil.addOptionalArgs(
          [
            Arg.CONFIG_FILE,
            Arg.IMPORT,
            Arg.NON_FATAL_VALIDATION_ERRORS,
            Arg.BCVES,
            Arg.SOURCES,
            Arg.RESULTS,
            Arg.ANONYMIZE,
            Arg.ALLOW_INCOMPLETE,
            Arg.NO_SOURCES,
            Arg.FILTER_TOOL,
            Arg.NO_EXPORT_FILE,
            Arg.EXPORT
          ],
          parser
        );
        argUtil.addArgs([Arg.SELECTORS], parser);
      };
    case Command.DOWNLOAD_COMMITS:
      return parser => {
        argUtil.addOptionalArgs(
          [
            Arg.CONFIG_FILE,
            Arg.NON_FATAL_VALIDATION_ERRORS,
            Arg.BCVES,
            Arg.SOURCES,
            Arg.ANONYMOUS
          ],
          parser
        );
        argUtil.addArgs([Arg.SELECTORS], parser);
      };
    case Command.VALIDATE:
      return parser => {
        argUtil.addArgs([Arg.SCHEMA, Arg.VALIDATE_FILES], parser);
      };
    case Command.UPLOAD_COMMITS:
      return parser => {
        argUtil.addOptionalArgs(
          [
            Arg.CONFIG_FILE,
            Arg.NON_FATAL_VALIDATION_ERRORS,
            Arg.BCVES,
            Arg.SOURCES
          ],
          parser
        );
        argUtil.addArgs([Arg.SELECTORS, Arg.AUTH_TOKEN], parser);
      };
  }
}

/**
 * @return the string that should be typed on the commandline to make use of `command`
 */
export function getCommandName(command: Command) {
  return strings.names.getCommandName(command);
}

/**
 * Creates a parser for the commandline arguments.
 */
export function mkCommandlineParser(
  forTesting: boolean // the argParse library does not behave very nicely with testing(!?), use this to limit its noisy behaviours
): argparse.ArgumentParser {
  // make the root parser
  let parser = new argparse.ArgumentParser(
      forTesting
        ? { exit_on_error: false }
        : {
            add_help: true,
            prog: "bin/cli",
            description: strings.help.main(),
            formatter_class: argparse.RawTextHelpFormatter
          }
    ),
    rootParser = parser,
    subparsers = rootParser.add_subparsers({ dest: "command" });

  // add the subparsers
  for (let k in Command) {
    if (!isNaN(Number(k))) {
      continue;
    }
    let command = Command[k as keyof typeof Command];
    let parser = subparsers.add_parser(
      strings.names.getCommandName(command),
      forTesting
        ? { exit_on_error: false }
        : {
            add_help: true,
            description: strings.help.getCommandHelp(command),
            formatter_class: argparse.RawTextHelpFormatter
          }
    );

    getSubparserSetup(command)(parser);
  }

  return rootParser;
}
