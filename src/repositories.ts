/**
 * Functions for interacting with VCS repositories and their web hosts.
 *
 * The supported VCS protocols are:
 *
 * - git
 *
 * The supported web hosts are:
 *
 * - github.com
 */
import * as axios from "axios";
import * as cp from "child_process";
import * as fs from "fs";
import * as path from "path";
import { BCVE, CommitID, Dir, RepositoryIdentifier } from "./persistent-types";
import { assert } from "./util";

function git(args: string[]) {
  cp.execFileSync("git", args, {
    env: { ...process.env, GIT_ASKPASS: "true" /* disables prompting */ }
  });
}
function tryParseGitHubRepositoryURL(repository: RepositoryIdentifier) {
  let url;
  try {
    url = new URL(repository);
  } catch (e) {
    return undefined;
  }
  if (url.protocol.match(/https?:/) && url.host === "github.com") {
    let parsed = url.pathname.match(/^\/(.+?)\/(.+?).git$/);
    if (parsed) {
      return { host: url.host, org: parsed[1], repo: parsed[2] };
    }
  }

  return undefined;
}

function mkGitUrl(host: string, path: string) {
  return `git@${host}:${path}.git`;
}
function downloadCommitFromRepository(
  repository: RepositoryIdentifier,
  commit: CommitID,
  dir: Dir,
  anonymous: boolean,
  logError: (msg: string) => void
): boolean {
  assert(repository);
  assert(commit);
  assert(dir);

  console.log(`Starting download of ${repository} ${commit} to ${dir}:`);
  let indent = "  ";
  if (fs.existsSync(dir)) {
    console.log(`${indent}Skipping download, ${dir} already exists`);
  } else {
    // use authorized clones if possible
    let github = tryParseGitHubRepositoryURL(repository),
      repositoryUrlToUse =
        github && !anonymous
          ? mkGitUrl(github.host, `${github.org}/${github.repo}`)
          : repository;

    let parent = path.dirname(dir);
    fs.mkdirSync(parent, { recursive: true });
    try {
      git(["clone", "--quiet", repositoryUrlToUse, dir]);
      console.log(`${indent}Clone complete`);
    } catch (e) {
      console.log(`${indent}Clone failed`);
      logError(
        `Download of ${repository} ${commit} to ${dir} failed: ${
          (e as Error).message
        }`
      );
      fs.rmdirSync(dir, { recursive: true });
    }
  }

  if (!fs.existsSync(dir)) {
    console.log(`${indent}${dir} does not exist, skipping checkout`);
    return false;
  } else {
    try {
      git(["-C", dir, "checkout", "--quiet", commit]);
      console.log(`${indent}Checkout complete`);
      return true;
    } catch (e) {
      logError(
        `Checkout of ${repository} ${commit} to ${dir} failed: ${
          (e as Error).message
        }`
      );
      fs.rmdirSync(dir, { recursive: true });
      return false;
    }
  }
}

function uploadCommitsToRepository(
  bcve: BCVE,
  repository: RepositoryIdentifier
): void {
  type CommitKind = "prePatch" | "postPatch";
  function uploadCommit(
    dir: Dir,
    commit: CommitID,
    repository: RepositoryIdentifier,
    branchName: CommitKind
  ) {
    if (!fs.existsSync(dir)) {
      console.error(
        `Source code directory ${dir} does not exist: can not upload commit to ${repository}`
      );
      return;
    }
    let args = ["-C", dir, "push", repository];
    // store with a convenient name, possibly overriding old upload
    git([...args, `--force`, `${commit}:refs/heads/${branchName}`]);
    // store permantly
    git([...args, `${commit}:refs/heads/commit-${commit}`]);
  }
  uploadCommit(
    bcve.prePatch.localSourceDirectory,
    bcve.prePatch.commit,
    repository,
    "prePatch"
  );
  uploadCommit(
    bcve.postPatch.localSourceDirectory,
    bcve.postPatch.commit,
    repository,
    "postPatch"
  );
}

export function downloadCommitFromARepository(
  candidateRepositories: RepositoryIdentifier[],
  commit: CommitID,
  dir: Dir,
  anonymous: boolean,
  logError: (msg: string) => void
): void {
  for (let repo of candidateRepositories) {
    let result = downloadCommitFromRepository(
      repo,
      commit,
      dir,
      anonymous,
      logError
    );
    if (result) {
      break;
    }
  }
}

export function makeCandidateRepositoryList(
  bcve: BCVE,
  canonicalRepositoriesRoot: string
): RepositoryIdentifier[] {
  return [
    bcve.repository,
    getCanonicalRepositoryIdentifier(bcve, canonicalRepositoriesRoot)
  ];
}
export function downloadCommitsForCVE(
  bcve: BCVE,
  anonymous: boolean,
  canonicalRepositoriesRoot: string,
  logError: (msg: string) => void
): void {
  if (bcve.prePatch.commit === bcve.postPatch.commit) {
    logError(
      `Aborting download of ${bcve.CVE}: prePatch.commit and postPatch.commit are identical: ${bcve.prePatch.commit}`
    );
    return;
  }
  let repositories = makeCandidateRepositoryList(
    bcve,
    canonicalRepositoriesRoot
  );
  downloadCommitFromARepository(
    repositories,
    bcve.postPatch.commit,
    bcve.postPatch.localSourceDirectory,
    anonymous,
    logError
  );
  let postPatchCommitParents = cp
    .execFileSync("git", [
      "-C",
      bcve.postPatch.localSourceDirectory,
      "rev-parse",
      "HEAD^@"
    ])
    .toString()
    .split("\n")
    .map(l => l.trim())
    .filter(l => !!l);
  if (!postPatchCommitParents.includes(bcve.prePatch.commit)) {
    logError(
      `Aborting download of ${bcve.CVE}/prePatch: ${
        bcve.prePatch.commit
      } is not in ${bcve.postPatch.commit}^@ (${postPatchCommitParents.join(
        ", "
      )})`
    );
    return;
  }
  downloadCommitFromARepository(
    repositories,
    bcve.prePatch.commit,
    bcve.prePatch.localSourceDirectory,
    anonymous,
    logError
  );
}

function getCanonicalRepositoryIdentifier(
  bcve: BCVE,
  canonicalRepositoriesRoot: string
): RepositoryIdentifier {
  return `${canonicalRepositoriesRoot}/${bcve.CVE}.git`;
}

function repositoryExists(repository: RepositoryIdentifier): boolean {
  try {
    let github = tryParseGitHubRepositoryURL(repository);
    let remote = repository;
    if (github) {
      remote = mkGitUrl(github.host, `${github.org}/${github.repo}`);
    }
    console.log(`Checking for existence of ${remote}`);
    git(["ls-remote", "-q", remote]);
    return true;
  } catch (e) {
    return false;
  }
}

async function createRepository(
  repository: RepositoryIdentifier,
  authToken: string
) {
  let github = tryParseGitHubRepositoryURL(repository);
  if (github) {
    let url = `https://api.${github.host}/orgs/${github.org}/repos`;
    let parameters = {
      name: github.repo,
      // lock down the repository as much as possible:
      private: true,
      has_issues: false,
      has_projects: false,
      has_wiki: false,
      is_template: false
    };
    let options = {
      headers: {
        Authorization: `token ${authToken}`
      }
    };
    console.log(`Creating repository: ${repository} using token: ${authToken}`);
    await axios.default.post(url, parameters, options);
    return;
  }
  throw new Error(`Can not (yet) create repository ${repository}`);
}

export async function uploadCVECommitsToCanonicalRepository(
  bcve: BCVE,
  canonicalRepositoriesRoot: string,
  authToken: string
): Promise<void> {
  let repository = getCanonicalRepositoryIdentifier(
    bcve,
    canonicalRepositoriesRoot
  );
  if (!repositoryExists(repository)) {
    await createRepository(repository, authToken);
  }
  let github = tryParseGitHubRepositoryURL(repository);
  if (github) {
    repository = mkGitUrl(github.host, `${github.org}/${github.repo}`);
  }
  uploadCommitsToRepository(bcve, repository);
}
