import ajv from "ajv";
import * as fs from "fs";
import * as path from "path";
import { checkUserProvidedFile, UserError } from "../util";
import { Config, File } from "../persistent-types";
import * as validation from "../validation";

/**
 * @return the validation errors that occur when `filesToValidate` are validated against `schemaName` with `validator`.
 */
function getValidationErrors(
  validator: ajv.Ajv,
  schemaName: validation.SchemaName,
  filesToValidate: File[]
) {
  return filesToValidate
    .map(file => {
      if (!fs.existsSync(file)) {
        return { file, error: `File does not exist` };
      }

      try {
        let data: any = JSON.parse(fs.readFileSync(file, "utf8"));
        return { file, data };
      } catch (e) {
        return {
          file,
          error: `Is not valid JSON: '${(e as Error).message}'`
        };
      }
    })
    .flatMap(({ file, data, error }) => {
      if (error) {
        return [{ file, error }];
      }
      let valid = validator.validate(validation.getSchemaID(schemaName), data);
      if (!valid) {
        return [
          {
            file,
            error: `Is not valid a valid ${schemaName}-file: ${validator.errorsText()}`
          }
        ];
      }
      return [];
    });
}

export default async (
  _config: Config,
  args: { schema: "BCVE" | "Log" | "Export"; files: string[] }
) => {
  let validator = validation.makeValidator(),
    schemaName =
      validation.SchemaName[args.schema as keyof typeof validation.SchemaName];
  if (!schemaName) {
    throw new UserError(
      `${args.schema} is not in ${JSON.stringify(
        Object.keys(validation.SchemaName)
      )}`
    );
  }
  args.files.forEach(f => checkUserProvidedFile(f));
  let filesToValidate = args.files.flatMap(f =>
    fs.lstatSync(f).isDirectory() // unfold directories one level
      ? fs
          .readdirSync(f)
          .map(c => path.resolve(f, c))
          .filter(f => !fs.lstatSync(f).isDirectory())
      : [f]
  );

  if (filesToValidate.length === 0) {
    throw new UserError(
      `No files to validate in ${filesToValidate.join(", ")}`
    );
  }
  let errors: string[] = getValidationErrors(
    validator,
    schemaName,
    filesToValidate
  )
    .map(({ file, error }) => `${file}: ${error}`)
    .sort();
  if (errors.length > 0) {
    throw new UserError(
      `Validation failed:\n${errors.map(e => `  - ${e}`).join("\n")}`
    );
  } else {
    console.log(`Validation succeeded for ${filesToValidate.length} files`);
  }
};
