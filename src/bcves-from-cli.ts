/**
 * Functions for fetching BCVEs containing varying amounts of information using inputs that are very close to the commandline.
 */

import * as fs from "fs";
import * as path from "path";
import * as selectors from "./selectors";
import {
  BCVE,
  BCVERun,
  Config,
  StandaloneRun,
  ToolID
} from "./persistent-types";
import {
  anonymizeBCVEs,
  checkUserProvidedFile,
  readBCVEFiles,
  readExportFile,
  readLogFile,
  readStdinLines,
  setDifference
} from "./util";

/**
 * @return `bcves` filtered to the ones that match `selectorStrings`.
 */
async function filterToCommandlineSelectors(
  bcves: BCVE[],
  selectorStrings: string[]
): Promise<BCVE[]> {
  if (selectorStrings.length === 1 && selectorStrings[0] === "-") {
    selectorStrings = (await readStdinLines()).filter(
      selectors.filterRawInputLine
    );
  }
  return selectors.filter(selectorStrings.map(selectors.parse), bcves);
}

/**
 * Modifies `bcves` to only contain runs for `toolIDs`.
 * The empty set of toolIDs matches all tools.
 */
function restrictRunsToToolIDs(bcves: BCVE[], toolIDs: Set<ToolID>): void {
  if (toolIDs.size === 0) {
    return;
  }
  bcves.forEach(bcve =>
    [bcve.prePatch, bcve.postPatch].forEach(c => {
      if (c.runs !== undefined) {
        c.runs = filterRunsToToolIDs(c.runs, toolIDs);
      }
    })
  );
}

/**
 * @return `runs` filtered to the ones that are for `toolIDs`.
 */
function filterRunsToToolIDs<T extends BCVERun | StandaloneRun>(
  runs: T[],
  toolIDs: Set<ToolID>
): T[] {
  return runs.filter(r => toolIDs.has(r.toolID));
}

/**
 * Throws an explanatory Error if `initialToolIDs` contains something `filteredToolIDs` does not.
 */
function checkForMissingToolIDsInRuns(
  initialToolIDs: ToolID[],
  filteredToolIDs: ToolID[]
) {
  let missingToolIDs = setDifference(
    new Set(initialToolIDs),
    new Set(filteredToolIDs)
  );
  if (missingToolIDs.size !== 0) {
    let missingString = JSON.stringify([...missingToolIDs].sort()),
      availableString = JSON.stringify([...new Set(filteredToolIDs)].sort());
    throw new Error(
      `No runs for: ${missingString}. Has runs for: ${availableString}.`
    );
  }
}

/**
 * Modifies `bcves` to contain their corresponding `runs`.
 */
function linkRuns(bcves: BCVE[], runs: StandaloneRun[]) {
  let bcvesByCVE: Map<string, BCVE> = new Map();
  bcves.forEach(bcve => bcvesByCVE.set(bcve.CVE, bcve));
  runs.forEach(standaloneRun => {
    let { CVE, commit, ...linkedRun } = standaloneRun;
    if (!bcvesByCVE.has(CVE)) {
      console.error(
        `Ignoring the run from ${standaloneRun.toolID} for ${CVE}, since there is no backing benchmark data.`
      );
      return;
    }
    let bcve = bcvesByCVE.get(CVE);
    switch (commit) {
      case bcve.prePatch.commit:
        bcve.prePatch.runs = bcve.prePatch.runs || [];
        bcve.prePatch.runs.push(linkedRun);
        break;
      case bcve.postPatch.commit:
        bcve.postPatch.runs = bcve.postPatch.runs || [];
        bcve.postPatch.runs.push(linkedRun);
        break;
      default:
        console.error(
          `Ignoring the run from ${standaloneRun.toolID} for commit ${
            standaloneRun.commit
          }, since ${CVE} (${JSON.stringify([
            bcve.prePatch.commit,
            bcve.postPatch.commit
          ])}) do not contain that commit.`
        );
    }
  });
}

/**
 * Gets BCVEs from disk according to `config` and `args`.
 */
export function getBCVEs(
  config: Config,
  args: {
    allow_incomplete: boolean;
    non_fatal_validation_errors: boolean;
    selectors: string[];
  },
  includeLocalSourceDirectory: boolean
): Promise<BCVE[]> {
  return filterToCommandlineSelectors(
    readBCVEFiles(
      config.bcves,
      includeLocalSourceDirectory ? config.sources : undefined,
      args.allow_incomplete,
      !args.non_fatal_validation_errors
    ),
    args.selectors
  );
}

/**
 * Gets BCVEs and their runs from disk according to `config` and `args`.
 *
 * If `allowUnmatchedTools` is `false`, an error is thrown if any of the specified `args.tool` ToolIDs are not matched with any runs.
 */
export async function getBCVEsWithRuns(
  config: Config,
  args: {
    selectors: string[];
    tool: ToolID[];
    allow_incomplete: boolean;
    non_fatal_validation_errors: boolean;
    import?: string;
    no_sources?: boolean;
    anonymize?: boolean;
  },
  allowUnmatchedTools: boolean
): Promise<BCVE[]> {
  let bcves;

  if (args.import) {
    checkUserProvidedFile(args.import);
    let imported = readExportFile(
      args.import,
      !args.non_fatal_validation_errors
    );
    bcves = await filterToCommandlineSelectors(imported, args.selectors);
    if (!allowUnmatchedTools) {
      checkForMissingToolIDsInRuns(
        args.tool,
        bcves.flatMap(bcve =>
          [bcve.postPatch, bcve.prePatch]
            .flatMap(c => c.runs || [])
            .flatMap(r => r.toolID)
        )
      );
    }
    restrictRunsToToolIDs(bcves, new Set(args.tool));
  } else {
    bcves = await getBCVEs(config, args, !args.no_sources);

    let cves = new Set(bcves.map(bcve => bcve.CVE)),
      runs = fs.existsSync(config.results)
        ? fs
            .readdirSync(config.results)
            .map(f => path.join(config.results, f))
            .map(f => {
              try {
                return readLogFile(f, !args.non_fatal_validation_errors);
              } catch (e) {
                console.error(`Ignoring invalid log file ${f}`);
              }
            })
            .filter(l => !!l)
            .flatMap(l => l.runs)
            .filter(run => cves.has(run.CVE))
        : [],
      toolIDs = new Set(args.tool);

    if (!allowUnmatchedTools) {
      checkForMissingToolIDsInRuns(
        args.tool,
        runs.map(r => r.toolID)
      );
    }
    linkRuns(
      bcves,
      toolIDs.size === 0 ? runs : filterRunsToToolIDs(runs, toolIDs)
    );
  }
  if (args.no_sources) {
    bcves.forEach(bcve =>
      [bcve.prePatch, bcve.postPatch].forEach(
        c => (c.localSourceDirectory = undefined)
      )
    );
  }

  if (args.anonymize) {
    anonymizeBCVEs(bcves);
  }
  return bcves;
}
